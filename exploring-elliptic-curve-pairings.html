<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Exploring Elliptic Curve Pairings | OGIest</title>
  <link rel="icon" href="favicon.ico"><link href="style.css" rel="stylesheet"></head>
  <body
    x-data="{ page: 'blog-single', 'darkMode': true, 'stickyMenu': false, 'navigationOpen': false, 'scrollTop': false }"
    x-init="
         darkMode = JSON.parse(localStorage.getItem('darkMode'));
         $watch('darkMode', value => localStorage.setItem('darkMode', JSON.stringify(value)))"
    :class="{'b eh': darkMode === true}"
  >
    <!-- ===== Header Start ===== -->
    <header
  class="g s r vd ya cj"
  :class="{ 'hh sm _k dj bl ll' : stickyMenu }"
  @scroll.window="stickyMenu = (window.pageYOffset > 20) ? true : false"
>
  <div class="bb ze ki xn 2xl:ud-px-0 oo wf yf i">
    <div class="vd to/4 tc wf yf">
      <a href="/">
        <img class="om" src="images/logo-light.png" alt="Logo Light" />
        <img class="xc nm" src="images/logo-dark.png" alt="Logo Dark" />
      </a>

      <!-- Hamburger Toggle BTN -->
      <button class="po rc" @click="navigationOpen = !navigationOpen">
        <span class="rc i pf re pd">
          <span class="du-block h q vd yc">
            <span class="rc i r s eh um tg te rd eb ml jl dl" :class="{ 'ue el': !navigationOpen }"></span>
            <span class="rc i r s eh um tg te rd eb ml jl fl" :class="{ 'ue qr': !navigationOpen }"></span>
            <span class="rc i r s eh um tg te rd eb ml jl gl" :class="{ 'ue hl': !navigationOpen }"></span>
          </span>
          <span class="du-block h q vd yc lf">
            <span class="rc eh um tg ml jl el h na r ve yc" :class="{ 'sd dl': !navigationOpen }"></span>
            <span class="rc eh um tg ml jl qr h s pa vd rd" :class="{ 'sd rr': !navigationOpen }"></span>
          </span>
        </span>
      </button>
      <!-- Hamburger Toggle BTN -->
    </div>

    <div
      class="vd wo/4 sd qo f ho oo wf yf"
      :class="{ 'd hh rm sr td ud qg ug jc yh': navigationOpen }"
    >
      <nav>
      </nav>

      <div class="tc wf ig pb no">
        <div class="pc h io pa ra" :class="navigationOpen ? '!-ud-visible' : 'd'">
          <label class="rc ab i">
            <input type="checkbox" :value="darkMode" @change="darkMode = !darkMode" class="pf vd yc uk h r za ab" />
            <!-- Icon Sun -->
            <svg :class="{ 'wn' : page === 'home', 'xh' : page === 'home' && stickyMenu }" class="th om" width="25" height="25" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12.0908 18.6363C10.3549 18.6363 8.69 17.9467 7.46249 16.7192C6.23497 15.4916 5.54537 13.8268 5.54537 12.0908C5.54537 10.3549 6.23497 8.69 7.46249 7.46249C8.69 6.23497 10.3549 5.54537 12.0908 5.54537C13.8268 5.54537 15.4916 6.23497 16.7192 7.46249C17.9467 8.69 18.6363 10.3549 18.6363 12.0908C18.6363 13.8268 17.9467 15.4916 16.7192 16.7192C15.4916 17.9467 13.8268 18.6363 12.0908 18.6363ZM12.0908 16.4545C13.2481 16.4545 14.358 15.9947 15.1764 15.1764C15.9947 14.358 16.4545 13.2481 16.4545 12.0908C16.4545 10.9335 15.9947 9.8236 15.1764 9.00526C14.358 8.18692 13.2481 7.72718 12.0908 7.72718C10.9335 7.72718 9.8236 8.18692 9.00526 9.00526C8.18692 9.8236 7.72718 10.9335 7.72718 12.0908C7.72718 13.2481 8.18692 14.358 9.00526 15.1764C9.8236 15.9947 10.9335 16.4545 12.0908 16.4545ZM10.9999 0.0908203H13.1817V3.36355H10.9999V0.0908203ZM10.9999 20.8181H13.1817V24.0908H10.9999V20.8181ZM2.83446 4.377L4.377 2.83446L6.69082 5.14828L5.14828 6.69082L2.83446 4.37809V4.377ZM17.4908 19.0334L19.0334 17.4908L21.3472 19.8046L19.8046 21.3472L17.4908 19.0334ZM19.8046 2.83337L21.3472 4.377L19.0334 6.69082L17.4908 5.14828L19.8046 2.83446V2.83337ZM5.14828 17.4908L6.69082 19.0334L4.377 21.3472L2.83446 19.8046L5.14828 17.4908ZM24.0908 10.9999V13.1817H20.8181V10.9999H24.0908ZM3.36355 10.9999V13.1817H0.0908203V10.9999H3.36355Z" fill=""/>
            </svg>
            <!-- Icon Sun -->
            <img class="xc nm" src="images/icon-moon.svg" alt="Moon" />
          </label>
        </div>
        <ul class="tc _o sf yo cg ep">
        <li><a href="about.html" :class="{ 'nk yl' : page === 'home', 'ok' : page === 'home' && stickyMenu }" class="ek pk xl">About</a></li>
        <li><a href="/" :class="{ 'nk yl' : page === 'home', 'ok' : page === 'home' && stickyMenu }" class="ek pk xl">Home</a></li>
        </ul>
      </div>
    </div>
  </div>
</header>

    <!-- ===== Header End ===== -->

    <main>
      <!-- ===== Blog Single Start ===== -->
      <section class="gj qp gr hj rp hr">
        <div class="bb ze ki xn 2xl:ud-px-0">
          <div class="tc sf yo zf kq">
            <div class="bb ze">
              <div class="animate_top rounded-md shadow-solid-13 bg-white dark:bg-blacksection border border-stroke dark:border-strokedark p-7.5 md:p-10">
                <h1 style="text-align: center;" class="ek vj 2xl:ud-text-title-lg kk wm nb gb">Exploring Elliptic Curve Pairings</h1><br />
                <center><img src="https://cdn-images-1.medium.com/v2/resize:fit:2000/1*alHa7VxwcLoJk4C_YU9Iog.png" style="max-width:100%;" alt="Blog"  /></center>
                <br />
                <ul class="tc uf cg 2xl:ud-gap-15 fb">
                  <li><span class="rc kk wm">Author: </span> Vitalik Buterin</li>
                  <li><span class="rc kk wm">Published On: </span> Jan 14, 2017</li>
                  <li><span class="rc kk wm">Category: </span> Generals</li>
                </ul>

                <p style="text-align: justify;" class="ob"><strong>Trigger warning: math.</strong></p>
                <p style="text-align: justify;" class="ob">One of the key cryptographic primitives behind various constructions, including deterministic threshold signatures, zk-SNARKs and other simpler forms of zero-knowledge proofs is the elliptic curve pairing. Elliptic curve pairings (or "bilinear maps") are a recent addition to a 30-year-long history of using elliptic curves for cryptographic applications including encryption and digital signatures; pairings introduce a form of "encrypted multiplication", greatly expanding what elliptic curve-based protocols can do. The purpose of this article will be to go into elliptic curve pairings in detail, and explain a general outline of how they work.</p>
                <p style="text-align: justify;" class="ob">You're not expected to understand everything here the first time you read it, or even the tenth time; this stuff is genuinely hard. But hopefully this article will give you at least a bit of an idea as to what is going on under the hood.</p>
                <p style="text-align: justify;" class="ob">Elliptic curves themselves are very much a nontrivial topic to understand, and this article will generally assume that you know how they work; if you do not, I recommend this article here as a primer: <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/</a>. As a quick summary, elliptic curve cryptography involves mathematical objects called "points" (these are literal two-dimensional points with <span class="math inline">\((x, y)\)</span> coordinates), with special formulas for adding and subtracting them (ie. for calculating the coordinates of <span class="math inline">\(R = P + Q\)</span>), and you can also multiply a point by an integer (ie. <span class="math inline">\(P \cdot n = P + P + ... + P\)</span>, though there's a much faster way to compute it if <span class="math inline">\(n\)</span> is big).</p>
                <br>
                <center>
                <img src="https://cdn-images-1.medium.com/max/2000/1*2PxXNwMceh1XC_waAP9NiA.jpeg" style="max-width:100%;" alt="Blog" /><br><br> <small><i>Here's how point addition looks like graphically.</i></small>
                </center>
                <br>
                <p style="text-align: justify;" class="ob">There exists a special point called the "point at infinity" (<span class="math inline">\(O\)</span>), the equivalent of zero in point arithmetic; it's always the case that <span class="math inline">\(P + O = P\)</span>. Also, a curve has an "<strong>order</strong>"; there exists a number <span class="math inline">\(n\)</span> such that <span class="math inline">\(P \cdot n = O\)</span> for any <span class="math inline">\(P\)</span> (and of course, <span class="math inline">\(P \cdot (n+1) = P, P \cdot (7 \cdot n + 5) = P \cdot 5\)</span>, and so on). There is also some commonly agreed upon "generator point" <span class="math inline">\(G\)</span>, which is understood to in some sense represent the number <span class="math inline">\(1\)</span>. Theoretically, any point on a curve (except <span class="math inline">\(O\)</span>) can be <span class="math inline">\(G\)</span>; all that matters is that <span class="math inline">\(G\)</span> is standardized.</p>
                <p style="text-align: justify;" class="ob">Pairings go a step further in that they allow you to check certain kinds of more complicated equations on elliptic curve points — for example, if <span class="math inline">\(P = G \cdot p, Q = G \cdot q\)</span> and <span class="math inline">\(R = G \cdot r\)</span>, you can check whether or not <span class="math inline">\(p \cdot q = r\)</span>, having just <span class="math inline">\(P, Q\)</span> and <span class="math inline">\(R\)</span> as inputs. This might seem like the fundamental security guarantees of elliptic curves are being broken, as information about <span class="math inline">\(p\)</span> is leaking from just knowing P, but it turns out that the leakage is highly contained — specifically, the <a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption">decisional Diffie Hellman problem</a> is easy, but the computational Diffie Hellman problem (knowing <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> in the above example, <em>computing</em> <span class="math inline">\(R = G \cdot p \cdot q\)</span>) and the <a href="https://en.wikipedia.org/wiki/Discrete_logarithm">discrete logarithm problem</a> (recovering <span class="math inline">\(p\)</span> from <span class="math inline">\(P\)</span>) remain computationally infeasible (at least, if they were before).</p>
                <p style="text-align: justify;" class="ob">A third way to look at what pairings do, and one that is perhaps most illuminating for most of the use cases that we are about, is that if you view elliptic curve points as one-way encrypted numbers (that is, <span class="math inline">\(encrypt(p) = p \cdot G = P\)</span>), then whereas traditional elliptic curve math lets you check <em>linear</em> constraints on the numbers (eg. if <span class="math inline">\(P = G \cdot p, Q = G \cdot q\)</span> and <span class="math inline">\(R = G \cdot r\)</span>, checking <span class="math inline">\(5 \cdot P + 7 \cdot Q = 11 \cdot R\)</span> is <em>really</em> checking that <span class="math inline">\(5 \cdot p + 7 \cdot q = 11 \cdot r\)</span>), pairings let you check <em>quadratic</em> constraints (eg. checking <span class="math inline">\(e(P, Q) \cdot e(G, G \cdot 5) = 1\)</span> is <em>really</em> checking that <span class="math inline">\(p \cdot q + 5 = 0\)</span>). And going up to quadratic is enough to let us work with deterministic threshold signatures, quadratic arithmetic programs and all that other good stuff.</p>
                <p style="text-align: justify;" class="ob">Now, what is this funny <span class="math inline">\(e(P, Q)\)</span> operator that we introduced above? This is the pairing. Mathematicians also sometimes call it a <em>bilinear map</em>; the word "bilinear" here basically means that it satisfies the constraints:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(e(P, Q + R) = e(P, Q) \cdot e(P, R)\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(e(P + S, Q) = e(P, Q) \cdot e(S, Q)\)</span></p>
                <p style="text-align: justify;" class="ob">Note that <span class="math inline">\(+\)</span> and <span class="math inline">\(\cdot\)</span> can be arbitrary operators; when you're creating fancy new kinds of mathematical objects, abstract algebra doesn't care how <span class="math inline">\(+\)</span> and <span class="math inline">\(\cdot\)</span> are <em>defined</em>, as long as they are consistent in the usual ways, eg. <span class="math inline">\(a + b = b + a, (a \cdot b) \cdot c = a \cdot (b \cdot c)\)</span> and <span class="math inline">\((a \cdot c) + (b \cdot c) = (a + b) \cdot c\)</span>.</p>
                <p style="text-align: justify;" class="ob">If <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, <span class="math inline">\(R\)</span> and <span class="math inline">\(S\)</span> were simple <em>numbers</em>, then making a simple pairing is easy: we can do <span class="math inline">\(e(x, y) = 2^{xy}\)</span>. Then, we can see:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(e(3, 4+ 5) = 2^{3 \cdot 9} = 2^{27}\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(e(3, 4) \cdot e(3, 5) = 2^{3 \cdot 4} \cdot 2^{3 \cdot 5} = 2^{12} \cdot 2^{15} = 2^{27}\)</span></p>
                <p style="text-align: justify;" class="ob">It's bilinear!</p>
                <p style="text-align: justify;" class="ob">However, such simple pairings are not suitable for cryptography because the objects that they work on are simple integers and are too easy to analyze; integers make it easy to divide, compute logarithms, and make various other computations; simple integers have no concept of a "public key" or a "one-way function". Additionally, with the pairing described above you can go backwards - knowing <span class="math inline">\(x\)</span>, and knowing <span class="math inline">\(e(x, y)\)</span>, you can simply compute a division and a logarithm to determine <span class="math inline">\(y\)</span>. We want mathematical objects that are as close as possible to "black boxes", where you can add, subtract, multiply and divide, <em>but do nothing else</em>. This is where elliptic curves and elliptic curve pairings come in.</p>
                <p style="text-align: justify;" class="ob">It turns out that it is possible to make a bilinear map over elliptic curve points — that is, come up with a function <span class="math inline">\(e(P, Q)\)</span> where the inputs <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are elliptic curve points, and where the output is what's called an <span class="math inline">\((F_p)^{12}\)</span> element (at least in the specific case we will cover here; the specifics differ depending on the details of the curve, more on this later), but the math behind doing so is quite complex.</p>
                <p style="text-align: justify;" class="ob">First, let's cover prime fields and extension fields. The pretty elliptic curve in the picture earlier in this post only looks that way if you assume that the curve equation is defined using regular real numbers. However, if we actually use regular real numbers in cryptography, then you can use logarithms to "go backwards", and everything breaks; additionally, the amount of space needed to actually store and represent the numbers may grow arbitrarily. Hence, we instead use numbers in a <strong>prime field</strong>.</p>
                <p style="text-align: justify;" class="ob">A prime field consists of the set of numbers <span class="math inline">\(0, 1, 2... p-1\)</span>, where <span class="math inline">\(p\)</span> is prime, and the various operations are defined as follows:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(a + b: (a + b)\)</span> % <span class="math inline">\(p\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(a \cdot b: (a \cdot b)\)</span> % <span class="math inline">\(p\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(a - b: (a - b)\)</span> % <span class="math inline">\(p\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(a / b: (a \cdot b^{p-2})\)</span> % <span class="math inline">\(p\)</span></p>
                <p style="text-align: justify;" class="ob">Basically, all math is done modulo <span class="math inline">\(p\)</span> (see <a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic">here</a> for an introduction to modular math). Division is a special case; normally, <span class="math inline">\(\frac{3}{2}\)</span> is not an integer, and here we want to deal only with integers, so we instead try to find the number <span class="math inline">\(x\)</span> such that <span class="math inline">\(x \cdot 2 = 3\)</span>, where <span class="math inline">\(\cdot\)</span> of course refers to modular multiplication as defined above. Thanks to <a href="https://en.wikipedia.org/wiki/Fermat&#39;s_little_theorem">Fermat's little theorem</a>, the exponentiation trick shown above does the job, but there is also a faster way to do it, using the <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended Euclidean Algorithm</a>. Suppose <span class="math inline">\(p = 7\)</span>; here are a few examples:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(2 + 3 = 5\)</span> % <span class="math inline">\(7 = 5\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(4 + 6 = 10\)</span> % <span class="math inline">\(7 = 3\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(2 - 5 = -3\)</span> % <span class="math inline">\(7 = 4\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(6 \cdot 3 = 18\)</span> % <span class="math inline">\(7 = 4\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(3 / 2 = (3 \cdot 2^5)\)</span> % <span class="math inline">\(7 = 5\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(5 \cdot 2 = 10\)</span> % <span class="math inline">\(7 = 3\)</span></p>
                <p style="text-align: justify;" class="ob">If you play around with this kind of math, you'll notice that it's perfectly consistent and satisfies all of the usual rules. The last two examples above show how <span class="math inline">\((a / b) \cdot b = a\)</span>; you can also see that <span class="math inline">\((a + b) + c = a + (b + c), (a + b) \cdot c = a \cdot c + b \cdot c\)</span>, and all the other high school algebraic identities you know and love continue to hold true as well. In elliptic curves in reality, the points and equations are usually computed in prime fields.</p>
                <p style="text-align: justify;" class="ob">Now, let's talk about <strong>extension fields</strong>. You have probably already seen an extension field before; the most common example that you encounter in math textbooks is the field of complex numbers, where the field of real numbers is "extended" with the additional element <span class="math inline">\(\sqrt{-1} = i\)</span>. Basically, extension fields work by taking an existing field, then "inventing" a new element and defining the relationship between that element and existing elements (in this case, <span class="math inline">\(i^2 + 1 = 0\)</span>), making sure that this equation does not hold true for any number that is in the original field, and looking at the set of all linear combinations of elements of the original field and the new element that you have just created.</p>
                <br>
                <center>
                <img src="https://cdn-images-1.medium.com/max/2000/1*qDOPI299SKvZuzeNnik4JA.png" style="max-width:100%;" alt="Blog" />
                </center>
                <p style="text-align: justify;" class="ob"><br></p>
                <p style="text-align: justify;" class="ob">We can do extensions of prime fields too; for example, we can extend the prime field <span class="math inline">\(\bmod 7\)</span> that we described above with <span class="math inline">\(i\)</span>, and then we can do:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\((2 + 3i) + (4 + 2i) = 6 + 5i\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\((5 + 2i) + 3 = 1 + 2i\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\((6 + 2i) \cdot 2 = 5 + 4i\)</span></p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(4i \cdot (2 + i) = 3 + i\)</span></p>
                <p style="text-align: justify;" class="ob">That last result may be a bit hard to figure out; what happened there was that we first decompose the product into <span class="math inline">\(4i \cdot 2 + 4i \cdot i\)</span>, which gives <span class="math inline">\(8i - 4\)</span>, and then because we are working in <span class="math inline">\(\bmod 7\)</span> math that becomes <span class="math inline">\(i + 3\)</span>. To divide, we do:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(a / b: (a \cdot b^{(p^2-2)})\)</span> % <span class="math inline">\(p\)</span></p>
                <p style="text-align: justify;" class="ob">Note that the exponent for Fermat's little theorem is now <span class="math inline">\(p^2\)</span> instead of <span class="math inline">\(p\)</span>, though once again if we want to be more efficient we can also instead extend the Extended Euclidean Algorithm to do the job. Note that <span class="math inline">\(x^{p^2 - 1} = 1\)</span> for any <span class="math inline">\(x\)</span> in this field, so we call <span class="math inline">\(p^2 - 1\)</span> the "order of the multiplicative group in the field".</p>
                <p style="text-align: justify;" class="ob">With real numbers, the <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_algebra">Fundamental Theorem of Algebra</a> ensures that the quadratic extension that we call the complex numbers is "complete" — you cannot extend it further, because for any mathematical relationship (at least, any mathematical relationship defined by an algebraic formula) that you can come up with between some new element <span class="math inline">\(j\)</span> and the existing complex numbers, it's possible to come up with at least one complex number that already satisfies that relationship. With prime fields, however, we do not have this issue, and so we can go further and make cubic extensions (where the mathematical relationship between some new element <span class="math inline">\(w\)</span> and existing field elements is a cubic equation, so <span class="math inline">\(1, w\)</span> and <span class="math inline">\(w^2\)</span> are all linearly independent of each other), higher-order extensions, extensions of extensions, etc. And it is these kinds of supercharged modular complex numbers that elliptic curve pairings are built on.</p>
                <p style="text-align: justify;" class="ob">For those interested in seeing the exact math involved in making all of these operations written out in code, prime fields and field extensions are implemented here: <a href="https://github.com/ethereum/py_pairing/blob/master/py_ecc/bn128/bn128_field_elements.py">https://github.com/ethereum/py_pairing/blob/master/py_ecc/bn128/bn128_field_elements.py</a></p>
                <p style="text-align: justify;" class="ob">Now, on to elliptic curve pairings. An elliptic curve pairing (or rather, the specific form of pairing we'll explore here; there are also other types of pairings, though their logic is fairly similar) is a map <span class="math inline">\(G_2 \times G_1 \rightarrow G_t\)</span>, where:</p>
                <ul>
                <li><p><span class="math inline">\(\bf G_1\)</span> is an elliptic curve, where points satisfy an equation of the form <span class="math inline">\(y^2 = x^3 + b\)</span>, and where both coordinates are elements of <span class="math inline">\(F_p\)</span> (ie. they are simple numbers, except arithmetic is all done modulo some prime number)</p></li>
                <li><p><span class="math inline">\(\bf G_2\)</span> is an elliptic curve, where points satisfy the same equation as <span class="math inline">\(G_1\)</span>, except where the coordinates are elements of <span class="math inline">\((F_p)^{12}\)</span> (ie. they are the supercharged complex numbers we talked about above; we define a new "magic number" <span class="math inline">\(w\)</span>, which is defined by a <span class="math inline">\(12\)</span>th degree polynomial like <span class="math inline">\(w^{12} - 18 \cdot w^6 + 82 = 0\)</span>)</p></li>
                <li><p><span class="math inline">\(\bf G_t\)</span> is the type of object that the result of the elliptic curve goes into. In the curves that we look at, <span class="math inline">\(G_t\)</span> is <span class="math inline">\(\bf (F_p)^{12}\)</span> (the same supercharged complex number as used in <span class="math inline">\(G_2\)</span>)</p></li>
                </ul>
                <p style="text-align: justify;" class="ob">The main property that it must satisfy is bilinearity, which in this context means that:</p>
                <ul>
                <li><p><span class="math inline">\(e(P, Q + R) = e(P, Q) \cdot e(P, R)\)</span></p></li>
                <li><p><span class="math inline">\(e(P + Q, R) = e(P, R) \cdot e(Q, R)\)</span></p></li>
                </ul>
                <p style="text-align: justify;" class="ob">There are two other important criteria:</p>
                <ul>
                <li><p><strong>Efficient computability</strong> (eg. we can make an easy pairing by simply taking the discrete logarithms of all points and multiplying them together, but this is as computationally hard as breaking elliptic curve cryptography in the first place, so it doesn't count)</p></li>
                <li><p><strong>Non-degeneracy</strong> (sure, you could just define <span class="math inline">\(e(P, Q) = 1\)</span>, but that's not a particularly useful pairing)</p></li>
                </ul>
                <p style="text-align: justify;" class="ob">So how do we do this?</p>
                <p style="text-align: justify;" class="ob">The math behind why pairing functions work is quite tricky and involves quite a bit of advanced algebra going even beyond what we've seen so far, but I'll provide an outline. First of all, we need to define the concept of a <strong>divisor</strong>, basically an alternative way of representing functions on elliptic curve points. A divisor of a function basically counts the zeroes and the infinities of the function. To see what this means, let's go through a few examples. Let us fix some point <span class="math inline">\(P = (P_x, P_y)\)</span>, and consider the following function:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(f(x, y) = x - P_x\)</span></p>
                <p style="text-align: justify;" class="ob">The divisor is <span class="math inline">\([P] + [-P] - 2 \cdot [O]\)</span> (the square brackets are used to represent the fact that we are referring to <em>the presence of the point <span class="math inline">\(P\)</span> in the set of zeroes and infinities of the function</em>, not the point P itself; <span class="math inline">\([P] + [Q]\)</span> is <strong>not</strong> the same thing as <span class="math inline">\([P + Q]\)</span>). The reasoning is as follows:</p>
                <ul>
                <li><p>The function is equal to zero at <span class="math inline">\(P\)</span>, since <span class="math inline">\(x\)</span> <em>is</em> <span class="math inline">\(P_x\)</span>, so <span class="math inline">\(x - P_x = 0\)</span></p></li>
                <li><p>The function is equal to zero at <span class="math inline">\(-P\)</span>, since <span class="math inline">\(-P\)</span> and <span class="math inline">\(P\)</span> share the same <span class="math inline">\(x\)</span> coordinate</p></li>
                <li><p>The function goes to infinity as <span class="math inline">\(x\)</span> goes to infinity, so we say the function is equal to infinity at <span class="math inline">\(O\)</span>. There's a technical reason why this infinity needs to be counted twice, so <span class="math inline">\(O\)</span> gets added with a "multiplicity" of <span class="math inline">\(-2\)</span> (negative because it's an infinity and not a zero, two because of this double counting).</p></li>
                </ul>
                <p style="text-align: justify;" class="ob">The technical reason is roughly this: because the equation of the curve is <span class="math inline">\(x^3 = y^2 + b, y\)</span> goes to infinity "<span class="math inline">\(1.5\)</span> times faster" than <span class="math inline">\(x\)</span> does in order for <span class="math inline">\(y^2\)</span> to keep up with <span class="math inline">\(x^3\)</span>; hence, if a linear function includes only <span class="math inline">\(x\)</span> then it is represented as an infinity of multiplicity <span class="math inline">\(2\)</span>, but if it includes <span class="math inline">\(y\)</span> then it is represented as an infinity of multiplicity <span class="math inline">\(3\)</span>.</p>
                <p style="text-align: justify;" class="ob">Now, consider a "line function":</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(ax + by + c = 0\)</span></p>
                <p style="text-align: justify;" class="ob">Where <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> are carefully chosen so that the line passes through points <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span>. Because of how elliptic curve addition works (see the diagram at the top), this also means that it passes through <span class="math inline">\(-P-Q\)</span>. And it goes up to infinity dependent on both <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, so the divisor becomes <span class="math inline">\([P]+ [Q] + [-P-Q] - 3 \cdot [O]\)</span>.</p>
                <br>
                <center>
                <img src="https://cdn-images-1.medium.com/max/2000/1*alHa7VxwcLoJk4C_YU9Iog.png" style="max-width:100%;" alt="Blog" />
                </center>
                <p style="text-align: justify;" class="ob"><br></p>
                <p style="text-align: justify;" class="ob">We know that every "rational function" (ie. a function defined only using a finite number of <span class="math inline">\(+, -, \cdot\)</span> and <span class="math inline">\(/\)</span> operations on the coordinates of the point) uniquely corresponds to some divisor, up to multiplication by a constant (ie. if two functions <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span> have the same divisor, then <span class="math inline">\(F = G \cdot k\)</span> for some constant <span class="math inline">\(k\)</span>).</p>
                <p style="text-align: justify;" class="ob">For any two functions <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span>, the divisor of <span class="math inline">\(F \cdot G\)</span> is equal to the divisor of <span class="math inline">\(F\)</span> plus the divisor of <span class="math inline">\(G\)</span> (in math textbooks, you'll see <span class="math inline">\((F \cdot G) = (F) + (G)\)</span>), so for example if <span class="math inline">\(f(x, y) = P_x - x\)</span>, then <span class="math inline">\((f^3) = 3 \cdot [P] + 3 \cdot [-P] - 6 \cdot [O]\)</span>; <span class="math inline">\(P\)</span> and <span class="math inline">\(-P\)</span> are "triple-counted" to account for the fact that <span class="math inline">\(f^3\)</span> approaches <span class="math inline">\(0\)</span> at those points "three times as quickly" in a certain mathematical sense.</p>
                <p style="text-align: justify;" class="ob">Note that there is a theorem that states that if you "remove the square brackets" from a divisor of a function, the points must add up to <span class="math inline">\(O ([P] + [Q] + [-P-Q] - 3 \cdot [O]\)</span> clearly fits, as <span class="math inline">\(P + Q - P - Q - 3 \cdot O = O)\)</span>, and any divisor that has this property is the divisor of a function.</p>
                <p style="text-align: justify;" class="ob">Now, we're ready to look at Tate pairings. Consider the following functions, defined via their divisors:</p>
                <ul>
                <li><p><span class="math inline">\((F_P) = n \cdot [P] - n \cdot [O]\)</span>, where <span class="math inline">\(n\)</span> is the order of <span class="math inline">\(G_1\)</span>, ie. <span class="math inline">\(n \cdot P = O\)</span> for any <span class="math inline">\(P\)</span></p></li>
                <li><p><span class="math inline">\((F_Q) = n \cdot [Q] - n \cdot [O]\)</span></p></li>
                <li><p><span class="math inline">\((g) = [P + Q] - [P] - [Q] + [O]\)</span></p></li>
                </ul>
                <p style="text-align: justify;" class="ob">Now, let's look at the product <span class="math inline">\(F_P \cdot F_Q \cdot g^n\)</span>. The divisor is:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(n \cdot [P] - n \cdot [O] + n \cdot [Q] - n \cdot [O] + n \cdot [P + Q] - n \cdot [P] - n \cdot [Q] + n \cdot [O]\)</span></p>
                <p style="text-align: justify;" class="ob">Which simplifies neatly to:</p>
                <p style="text-align: justify;" class="ob"><span class="math inline">\(n \cdot [P + Q] - n \cdot [O]\)</span></p>
                <p style="text-align: justify;" class="ob">Notice that this divisor is of exactly the same format as the divisor for <span class="math inline">\(F_P\)</span> and <span class="math inline">\(F_Q\)</span> above. Hence, <span class="math inline">\(F_P \cdot F_Q \cdot g^n = F_{P + Q}\)</span>.</p>
                <p style="text-align: justify;" class="ob">Now, we introduce a procedure called the "final exponentiation" step, where we take the result of our functions above (<span class="math inline">\(F_P, F_Q\)</span>, etc.) and raise it to the power <span class="math inline">\(z = (p^{12} - 1) / n\)</span>, where <span class="math inline">\(p^{12} - 1\)</span> is the order of the multiplicative group in <span class="math inline">\((F_p)^{12}\)</span> (ie. for <em>any</em> <span class="math inline">\(x \in (F_p)^{12}, x^{(p^{12} - 1)} = 1\)</span>). Notice that if you apply this exponentiation to any result that has <em>already</em> been raised to the power of <span class="math inline">\(n\)</span>, you get an exponentiation to the power of <span class="math inline">\(p^{12} - 1\)</span>, so the result turns into <span class="math inline">\(1\)</span>. Hence, after final exponentiation, <span class="math inline">\(g^n\)</span> cancels out and we get <span class="math inline">\(F_P^z \cdot F_Q^z = (F_{P + Q})^z\)</span>. There's some bilinearity for you.</p>
                <p style="text-align: justify;" class="ob">Now, if you want to make a function that's bilinear in both arguments, you need to go into spookier math, where instead of taking <span class="math inline">\(F_P\)</span> of a value directly, you take <span class="math inline">\(F_P\)</span> of a <em>divisor</em>, and that's where the full "Tate pairing" comes from. To prove some more results you have to deal with notions like "linear equivalence" and "Weil reciprocity", and the rabbit hole goes on from there. You can find more reading material on all of this <a href="http://www.math.ru.nl/~bosma/Students/MScThesis_DennisMeffert.pdf">here</a> and <a href="http://people.cs.nctu.edu.tw/~rjchen/ECC2012S/Elliptic%20Curves%20Number%20Theory%20And%20Cryptography%202n.pdf">here</a>.</p>
                <p style="text-align: justify;" class="ob">For an implementation of a modified version of the Tate pairing, called the optimal Ate paring, <a href="https://github.com/ethereum/py_pairing/blob/master/py_ecc/bn128/bn128_pairing.py">see here</a>. The code implements <a href="https://crypto.stanford.edu/pbc/notes/ep/miller.html">Miller's algorithm</a>, which is needed to actually compute <span class="math inline">\(F_P\)</span>.</p>
                <p style="text-align: justify;" class="ob">Note that the fact pairings like this are possible is somewhat of a mixed blessing: on the one hand, it means that all the protocols we can do with pairings become possible, but is also means that we have to be more careful about what elliptic curves we use.</p>
                <p style="text-align: justify;" class="ob">Every elliptic curve has a value called an <em>embedding degree</em>; essentially, the smallest <span class="math inline">\(k\)</span> such that <span class="math inline">\(p^k - 1\)</span> is a multiple of <span class="math inline">\(n\)</span> (where <span class="math inline">\(p\)</span> is the prime used for the field and <span class="math inline">\(n\)</span> is the curve order). In the fields above, <span class="math inline">\(k = 12\)</span>, and in the fields used for traditional ECC (ie. where we don't care about pairings), the embedding degree is often extremely large, to the point that pairings are computationally infeasible to compute; however, if we are not careful then we can generate fields where <span class="math inline">\(k = 4\)</span> or even <span class="math inline">\(1\)</span>.</p>
                <p style="text-align: justify;" class="ob">If <span class="math inline">\(k = 1\)</span>, then the "discrete logarithm" problem for elliptic curves (essentially, recovering <span class="math inline">\(p\)</span> knowing only the point <span class="math inline">\(P = G \cdot p\)</span>, the problem that you have to solve to "crack" an elliptic curve private key) can be reduced into a similar math problem over <span class="math inline">\(F_p\)</span>, where the problem becomes much easier (this is called the <a href="https://crypto.stanford.edu/pbc/notes/elliptic/movattack.html">MOV attack</a>); using curves with an embedding degree of <span class="math inline">\(12\)</span> or higher ensures that this reduction is either unavailable, or that solving the discrete log problem over pairing results is at least as hard as recovering a private key from a public key "the normal way" (ie. computationally infeasible). Do not worry; all standard curve parameters have been thoroughly checked for this issue.</p>
                <p style="text-align: justify;" class="ob">Stay tuned for a mathematical explanation of how zk-SNARKs work, coming soon.</p>
                <p style="text-align: justify;" class="ob"><em>Special thanks to Christian Reitwiessner, Ariel Gabizon (from Zcash) and Alfred Menezes for reviewing and making corrections.</em></p>
                </div>
            </div>
                 </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <!-- ===== Blog Single End ===== -->

      <!-- ===== CTA Start ===== -->
      <section class="i pg gh ji">
        <!-- Bg Shape -->
          <img class="h p q" src="images/shape-16.svg" alt="Bg Shape" />
      
          <div class="bb ye i z-10 ki xn dr">
            <div class="tc uf sn tn un gg">
           <div class="animate_left to/2">
              <a class="vc ek kk hh rg ol il cm gi hi">
                So which of the favors of your Lord would you deny?
              </a>
            </div>
          </div>
        </section>
      
            <!-- ===== CTA End ===== -->
    </main>
    <!-- ===== Footer Start ===== -->
    <footer>
      <div class="bb ze ki xn 2xl:ud-px-0">
        <!-- Footer Bottom -->
          <div class="bh ch pm tc uf sf yo wf xf ap cg fp bj">
          <div class="animate_top">
            <a href="/">
              <img src="images/logo-light.png" alt="Logo" class="om" />
              <img src="images/logo-dark.png" alt="Logo" class="xc nm" />
            </a>
            </div>
    
          <div class="animate_top">
            <p style="text-align: justify;" class="ob">&copy; Ogiest. All rights reserved</p>
          </div>
        </div>
        <!-- Footer Bottom -->
      </div>
    </footer>
    
    <!-- ===== Footer End ===== -->

    <!-- ====== Back To Top Start ===== -->
    <button
  class="xc wf xf ie ld vg sr gh tr g sa ta _a"
  @click="window.scrollTo({top: 0, behavior: 'smooth'})"
  @scroll.window="scrollTop = (window.pageYOffset > 50) ? true : false"
  :class="{ 'uc' : scrollTop }"
>
  <svg class="uh se qd" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path d="M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z" />
  </svg>
</button>

    <!-- ====== Back To Top End ===== -->
  <script defer src="bundle.js"></script></body>
</html>
